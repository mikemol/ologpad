# src/dsl_parser/grammar/bootstrap.py
"""
Defines the bootstrap grammar for the system.

This module provides the initial, "seed" grammar as a direct, in-code
data structure (a list of ASTNodes). This avoids the need for a hand-coded
parser to parse the initial grammar text.

This grammar is minimal but sufficient to parse the EBNF rules needed to
define more complex grammars, including the full EBNF specification itself.
"""
from typing import List

# Relative import from within the 'dsl_parser' package
from ..core.ast import ASTNode

def get_bootstrap_grammar() -> List[ASTNode]:
    """
    Constructs and returns the minimal grammar needed to bootstrap the system.

    This grammar can parse basic rule definitions of the form:
    RuleName ::= Symbol1 Symbol2 | Symbol3 ;

    It relies on a separate, pre-loaded set of foundational rules (like
    'Letter', 'Whitespace', etc. from unicode_rules.py) to handle the
    character-level recognition.

    Returns:
        A list of ASTNode objects representing the bootstrap grammar.
    """
    
    # Each rule is manually constructed as an AST, which is then used to
    # initialize the parser.
    
    # Rule to define a grammar as a sequence of rules.
    grammar_rule = ASTNode('Rule', children=[
        ASTNode('Identifier', value='Grammar'),
        ASTNode('Definition', children=[
            ASTNode('Repetition', children=[ # Represents 'Rule+'
                ASTNode('Identifier', value='Rule')
            ])
        ])
    ])

    # Rule for parsing a single rule: `Identifier ::= Definition ;`
    rule_definition = ASTNode('Rule', children=[
        ASTNode('Identifier', value='Rule'),
        ASTNode('Definition', children=[
            ASTNode('Sequence', children=[
                ASTNode('Identifier', value='Identifier'),
                ASTNode('Literal', value='::='),
                ASTNode('Identifier', value='Definition'),
                ASTNode('Literal', value=';')
            ])
        ])
    ])

    # Rule for a definition, which is a choice of expressions: `Expr1 | Expr2`
    definition_rule = ASTNode('Rule', children=[
        ASTNode('Identifier', value='Definition'),
        ASTNode('Definition', children=[
            ASTNode('Sequence', children=[
                ASTNode('Identifier', value='Expression'),
                ASTNode('Optional', children=[ # Represents `(...)*`
                    ASTNode('Sequence', children=[
                        ASTNode('Literal', value='|'),
                        ASTNode('Identifier', value='Expression')
                    ])
                ])
            ])
        ])
    ])

    # An Expression is a sequence of Terms: `Term1 Term2`
    expression_rule = ASTNode('Rule', children=[
        ASTNode('Identifier', value='Expression'),
        ASTNode('Definition', children=[
            ASTNode('Repetition', children=[ # Represents `Term+`
                ASTNode('Identifier', value='Term')
            ])
        ])
    ])

    # A Term can be an Identifier, a Literal string, or a group/range.
    # For bootstrap, we only need Identifier and Literal.
    term_rule = ASTNode('Rule', children=[
        ASTNode('Identifier', value='Term'),
        ASTNode('Definition', children=[
            ASTNode('Choice', children=[
                ASTNode('Identifier', value='Identifier'),
                ASTNode('Identifier', value='QuotedString')
            ])
        ])
    ])

    # NOTE: The actual definitions for 'Identifier', 'QuotedString', etc.,
    # are assumed to be provided by a foundational ruleset, like the one
    # generated by `unicode_rules.py`. This bootstrap grammar only defines
    # the *structure* of a grammar definition.

    return [
        grammar_rule,
        rule_definition,
        definition_rule,
        expression_rule,
        term_rule,
    ]

if __name__ == '__main__':
    print("--- Bootstrap Grammar Generation Demonstration ---")
    bootstrap_ast = get_bootstrap_grammar()
    
    print(f"Generated {len(bootstrap_ast)} bootstrap rules as ASTNode objects.")
    print("\nExample AST for the 'Rule' definition:")
    
    # Find the AST node that defines the 'Rule' structure
    rule_def_ast = next(r for r in bootstrap_ast if r.children[0].value == 'Rule')
    print(rule_def_ast)

    print("\nâœ… Bootstrap grammar is defined.")
